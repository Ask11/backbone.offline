// Generated by CoffeeScript 1.6.3
(function() {
  define(['backbone', 'underscore', 'Lawnchair', 'vent'],function(Backbone, _, Lawnchair, vent) {

    var Custom_Local_Storage = Lawnchair({name: 'QFlocalStorage'}, function(){
    });
    
    var Offline;
    
    Offline = {
      VERSION: '0.5.0',
      localSync: function(method, model, options, store) {
        var resp, _ref;

        //Add auth options
        //Get local auth
        if (localStorage.getItem('qform_session')) {
          //Set user
          var user = JSON.parse(localStorage.getItem('qform_session'));
          //Creat auth function
          function sendAuthentication(xhr){
            //Check if user has token
            if (user.token) {
              xhr.setRequestHeader('x-access-token', user.token);
            }else{
              xhr.setRequestHeader('Access-Token', user._id);
            };
          };
          //Add to options
          options.beforeSend = sendAuthentication;
        };

        var callback = function(resp) {
          //Make Async
          if (resp) {
            options.success((_ref = resp.attributes) != null ? _ref : resp, options);
          } else {
            typeof options.error === "function" ? options.error('Record not found') : void 0;
          }
        };
        switch (method) {
          case 'read':
            if (_.isUndefined(model.id)) {
              store.findAll(options, callback);
            } else {
              store.find(model, options, callback);
            }
            break;
          case 'create':
            callback(store.create(model, options));
            break;
          case 'update':
            callback(store.update(model, options));
            break;
          case 'delete':
            callback(store.destroy(model, options));
            break;
        }
        
      },
      sync: function(method, model, options) {
        var store, _ref;
        store = model.storage || ((_ref = model.collection) != null ? _ref.storage : void 0);

        if (store && (store != null ? store.support : void 0)) {
          return Offline.localSync(method, model, options, store);
        } else if (!options.local) {
          return Backbone.ajaxSync(method, model, options);
        }
      },
      onLine: function() {

        if(navigator.network){
          var networkState = navigator.network.connection.type;

          var states = {};
          states[Connection.UNKNOWN]  = 6;
          states[Connection.ETHERNET] = 5;
          states[Connection.WIFI]     = 4;
          states[Connection.CELL_4G]  = 3;
          states[Connection.CELL_3G]  = 2;
          states[Connection.CELL_2G]  = 1;
          states[Connection.NONE]     = 0;

          

          return states[networkState] !== 0;

          alert('Connection type: ' + states[networkState]);
        }else{
          return navigator.onLine !== false;
        }
      }
    };
    Backbone.ajaxSync = Backbone.sync;
    Backbone.sync = Offline.sync;

    Offline.Storage = (function() {

      function Storage(name, collection, options) {
        this.name = name;
        this.collection = collection;
        if (options == null) {
          options = {};
        }
        this.support = true;
        this.allIds = new Offline.Index(this.name, this);
        this.destroyIds = new Offline.Index("" + this.name + "-destroy", this);
        this.sync = new Offline.Sync(this.collection, this);
        this.keys = options.keys || {};
        this.autoPush = options.autoPush || false;
      }

      Storage.prototype.setItem = function(key, value) {
        var e;
        try {
          //save record locally
          Custom_Local_Storage.save({key:key , value:value});
          //Return
          return value;
        } catch (_error) {
          e = _error;
          if (e.name === 'QUOTA_EXCEEDED_ERR') {
            return this.collection.trigger('quota_exceed');
          } else {
            return value;
          }
        }
      };

      Storage.prototype.removeItem = function(key) {
        return Custom_Local_Storage.remove(key);
      };

      Storage.prototype.getItem = function(key,callback) {
        Custom_Local_Storage.get(key, function(record){
          callback(record?record.value:null);
        });
      };

      Storage.prototype.getItems = function(key,callback) {
        Custom_Local_Storage.get(key, function(records){
          //Init results
          var resutls = [];
          //Check if records exist
          if(records){
            //Get record objects
            var record_length = records.length;
            for (var i = 0; i < record_length; i++) {
              resutls.push(JSON.parse(records[i].value)); 
            };
          }
          //Send back results
          callback(resutls);
        });
      };

      Storage.prototype.create = function(model, options) {
        if (options == null) {
          options = {};
        }
        options.regenerateId = true;
        return this.save(model, options);
      };

      Storage.prototype.update = function(model, options) {
        if (options == null) {
          options = {};
        }
        return this.save(model, options);
      };

      Storage.prototype.destroy = function(model, options) {
        var sid;
        if (options == null) {
          options = {};
        }
        if (!(options.local || (sid = model.get('sid')) === 'new')) {
          this.destroyIds.add(sid);
        }
        return this.remove(model, options);
      };

      Storage.prototype.find = function(model, options, callback) {
        if (options == null) {
          options = {};
        }
        //Asunc
        this.getItem("" + this.name + "-" + model.id, function(item){
          callback(JSON.parse(item));
        });
      };

      Storage.prototype.findAll = function(options, callback) {
        
        var that = this;

        var _ref, _ref_new;
        if (options == null) {
          options = {};
        };
        function start_sync(items){
          //Check what sync is required
          if (!options.local) {
            if (items.length === 0) {
              that.sync.full(options);
            } else {
              that.sync.incremental(options);
            }
          };//End Check local
        }
        //Get all ids in async
        //Get store item with all ids
        this.getItem(this.name,function(item_ids){
          //These are all store ids
          _ref = (item_ids && item_ids.split(',')) || [];
          //this var will hold all store ids that are limited
          _ref_new =  ( _ref.length > 0 ) ? [] : '';
          //Check if there is a record limit
          var record_limit = options.limit ? _ref.length >= options.limit ? options.limit : _ref.length : _ref.length ;
          //If there are record limits, reverse the array
          if (options.limit) {
            _ref.reverse();
          };
          //Update all store ids with store name
          for (var i = 0; i < record_limit; i++) {
            _ref_new.push("" + that.name + "-" + _ref[i]);
          };
          //Get All items from storage
          that.getItems(_ref_new, function(items){
            //Sync
            start_sync(items);
            //Return Items
            callback(items);
          });

        });//END GET Store Item  
        

      };

      Storage.prototype.s4 = function() {
        return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
      };

      Storage.prototype.incrementId = 0x1000000;

      Storage.prototype.localId1 = ((1 + Math.random()) * 0x100000 | 0).toString(16).substring(1);

      Storage.prototype.localId2 = ((1 + Math.random()) * 0x100000 | 0).toString(16).substring(1);

      Storage.prototype.mid = function() {
        return ((new Date).getTime() / 1000 | 0).toString(16) + this.localId1 + this.localId2 + (++this.incrementId).toString(16).substring(1);
      };

      Storage.prototype.guid = function() {
        return this.s4() + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + this.s4() + this.s4();
      };

      Storage.prototype.save = function(item, options) {
        var newId, _ref, _ref1;
        if (options == null) {
          options = {};
        }
        if (options.regenerateId) {
          newId = options.id === 'mid' ? this.mid() : this.guid();
          item.set({
            sid: ((_ref = item.attributes) != null ? _ref.sid : void 0) || ((_ref1 = item.attributes) != null ? _ref1.id : void 0) || 'new',
            id: newId
          });
        }

        if (!options.local) {
          item.set({
            updated_at: (new Date()).toJSON(),
            dirty: true
          });
        }
        this.replaceKeyFields(item, 'local');
        this.setItem("" + this.name + "-" + item.id, JSON.stringify(item));
        this.allIds.add(item.id);
        if (this.autoPush && !options.local) {
          this.sync.pushItem(item);
        }
        return item;
      };

      Storage.prototype.remove = function(item, options) {
        var sid;
        if (options == null) {
          options = {};
        }
        this.removeItem("" + this.name + "-" + item.id);
        this.allIds.remove(item.id);
        sid = item.get('sid');
        if (this.autoPush && sid !== 'new' && !options.local) {
          this.sync.flushItem(sid);
        }
        return item;
      };

      Storage.prototype.isEmpty = function(callback) {
        this.getItem(this.name,function(item){
          callback(item === null);
        });
      };

      Storage.prototype.clear = function(callback) {
        var collectionKeys, key, keys, record, _i, _j, _len, _len1, _ref, _results,
          _this = this;
        //keys = Object.keys(localStorage);
        Custom_Local_Storage.keys(function(keys) {
          keys = keys;
          collectionKeys = _.filter(keys, function(key) {
            return (new RegExp(_this.name)).test(key);
          });
          for (_i = 0, _len = collectionKeys.length; _i < _len; _i++) {
            key = collectionKeys[_i];
            _this.removeItem(key);
          }
          _ref = [_this.allIds, _this.destroyIds]; //THIS NEEDS UPDATING
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            record = _ref[_j];
            _results.push(record.reset());
          }
          callback(_results);
        });//END Get Keys
        
      };

      Storage.prototype.replaceKeyFields = function(item, method) {
        var collection, field, newValue, replacedField, wrapper, _ref, _ref1, _ref2;
        if (Offline.onLine()) {
          if (item.attributes) {
            item = item.attributes;
          }
          _ref = this.keys;
          for (field in _ref) {
            collection = _ref[field];
            replacedField = item[field];
            if (!/^\w{8}-\w{4}-\w{4}/.test(replacedField) || method !== 'local') {
              newValue = method === 'local' ? (wrapper = new Offline.Collection(collection), (_ref1 = wrapper.get(replacedField)) != null ? _ref1.id : void 0) : (_ref2 = collection.get(replacedField)) != null ? _ref2.get('sid') : void 0;
              if (!_.isUndefined(newValue)) {
                item[field] = newValue;
              }
            }
          }
        }
        return item;
      };

      return Storage;

    })();
    Offline.Sync = (function() {
      function Sync(collection, storage) {
        this.collection = new Offline.Collection(collection);
        this.storage = storage;
      }

      Sync.prototype.ajax = function(method, model, options) {
        
        if(!options.headers){
          options.headers = {};
        }
        options.headers['Access-Token'] = localStorage.getItem('qform_session') ? JSON.parse(localStorage.getItem('qform_session'))._id : ''; //Add Access Token
        
        if (Offline.onLine()) {
          
          //this.prepareOptions(options);
          return Backbone.ajaxSync(method, model, options);
        } else {
          
          //return this.storage.setItem('offline', 'true');
        }
      };

      Sync.prototype.full = function(options) {
        var _this = this;
        if (options == null) {
          options = {};
        }
        return this.ajax('read', this.collection.items, _.extend({}, options, {
          success: function(models, opts) {
            var item, _i, _len;
            _this.storage.clear(function(results){
              //Reset Backbone Collection
              _this.collection.items.reset([], {
                silent: true
              });
              //Create Local Items
              for (_i = 0, _len = models.length; _i < _len; _i++) {
                item = models[_i];
                //Create Item Locally
                _this.collection.items.create(item, {
                  silent: true,
                  local: true,
                  regenerateId: true
                });
              }
              //Reset Collection
              if (!options.silent) {
                _this.collection.items.trigger('reset');
              }
              //Pass success callback
              if (options.success) {
                options.success(models, opts);
              }
            });
            
          }
        }));
      };

      Sync.prototype.incremental = function(options) {
        
        var _this = this;
        if (options == null) {
          options = {};
        }
        return this.pull(_.extend({}, options, {
          success: function() {

            return _this.push();
          }
        }));
      };

      Sync.prototype.prepareOptions = function(options) {
        
        var success,
          _this = this;
        if (this.storage.getItem('offline')) {
          this.storage.removeItem('offline');
          success = options.success;
          return options.success = function(model, opts) {
            
            success(model, opts);
            return _this.incremental();
          };
        }
      };

      Sync.prototype.pull = function(options) {
        

        var _this = this;
        if (options == null) {
          options = {};
        }
        return this.ajax('read', this.collection.items, _.extend({}, options, {
          success: function(models, opts) {
            var item, _i, _len;

            _this.collection.destroyDiff(models);
            
            for (_i = 0, _len = models.length; _i < _len; _i++) {
              item = models[_i];
              _this.pullItem(item);
            }
            if (options.success) {
              return options.success(models, opts);
            }
          }
        }));
      };

      Sync.prototype.pullItem = function(item) {
        var local;
        local = this.collection.get(item.id);
        if (local) {
          return this.updateItem(item, local);
        } else {
          return this.createItem(item);
        }
      };

      Sync.prototype.createItem = function(item) {
        
        if (!_.include(this.storage.destroyIds.values, item.id.toString())) {
          
          var user_token = localStorage.getItem('qform_session') ? JSON.parse(localStorage.getItem('qform_session'))._id : '';
          
          item.sid = item.id;
          delete item.id;
          return this.collection.items.create(item, {
            local: true,
            headers: 
              {'Access-Token': user_token} //Add Access Token}
          });
        }
      };

      Sync.prototype.updateItem = function(item, model) {
        if ((new Date(model.get('updated_at'))) < (new Date(item.updated_at)) || !model.get('updated_at')) {
          
          var user_token = localStorage.getItem('qform_session') ? JSON.parse(localStorage.getItem('qform_session'))._id : '';
          
          delete item.id;
          return model.save(item, {
            local: true,
            headers: 
              {'Access-Token': user_token} //Add Access Token}
          });
        }
      };

      Sync.prototype.push = function() {

        var item, sid, _i, _j, _len, _len1, _ref, _ref1, _results;
        _ref = this.collection.dirty();

        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          this.pushItem(item);
        }
        _ref1 = this.storage.destroyIds.values;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          sid = _ref1[_j];
          _results.push(this.flushItem(sid));
        }
        return _results;
      };

      Sync.prototype.pushItem = function(item) {
        var localId, method, _ref,
          _this = this;
        this.storage.replaceKeyFields(item, 'server');
        localId = item.id;
        delete item.attributes.id;
        _ref = item.get('sid') === 'new' ? ['create', null] : ['update', item.attributes.sid], method = _ref[0], item.id = _ref[1];
        this.ajax(method, item, {
          success: function(model, opts) {
            if (method === 'create') {
              //Emit Event That Model Has been Created
              vent.trigger("model:create",{model:model,item:item});
              //Set Local
              item.set({
                sid: model.id
              });
            } else {
              //Emit Event That Model Has been Updated
              vent.trigger("model:update",{model:model,item:item});
            }

            return item.save({
              dirty: false
            }, {
              local: true
            });
          }
        });
        item.attributes.id = localId;
        return item.id = localId;
      };

      Sync.prototype.flushItem = function(sid) {
        var model,
          _this = this;
        model = this.collection.fakeModel(sid);
        return this.ajax('delete', model, {
          success: function(model, opts) {
            return _this.storage.destroyIds.remove(sid);
          }
        });
      };

      return Sync;

    })();

    Offline.Index = (function() {
      function Index(name, storage) {
        var _this = this;
        var store;
        this.name = name;
        this.storage = storage;
        //Update to async
        this.values = [];
        this.storage.getItem(this.name,function(store){
          store = store;
          _this.values = (store && store.split(',')) || [];
          if(name.indexOf('-destroy') > -1){
            _this.destroyIds = _this.values;
          }else{
            _this.allIds = _this.values;
          };
        });
      }

      Index.prototype.add = function(itemId) {
        if (!_.include(this.values, itemId.toString())) {
          this.values.push(itemId.toString());
        }
        return this.save();
      };

      Index.prototype.remove = function(itemId) {
        this.values = _.without(this.values, itemId.toString());
        return this.save();
      };

      Index.prototype.save = function() {
        return this.storage.setItem(this.name, this.values.join(','));
      };

      Index.prototype.reset = function() {
        this.values = [];
        return this.storage.removeItem(this.name);
      };

      return Index;

    })();
    
    Offline.Collection = (function() {
      function Collection(items) {
        this.items = items;
      }

      Collection.prototype.dirty = function() {
        return this.items.where({
          dirty: true
        });
      };

      Collection.prototype.get = function(sid) {
        return this.items.find(function(item) {
          return item.get('sid') === sid;
        });
        // return this.items.where({
        //   sid: sid
        // });
      };

      Collection.prototype.destroyDiff = function(response) {
        var diff, sid, _i, _len, _ref, _results;
        diff = _.difference(_.without(this.items.pluck('sid'), 'new'), _.pluck(response, 'id'));
        _results = [];
        for (_i = 0, _len = diff.length; _i < _len; _i++) {
          sid = diff[_i];
          _results.push((_ref = this.get(sid)) != null ? _ref.destroy({
            local: true
          }) : void 0);
        }
        return _results;
      };

      Collection.prototype.fakeModel = function(sid) {
        var model;
        model = new Backbone.Model({
          id: sid
        });
        model.urlRoot = this.items.url;
        return model;
      };

      return Collection;

    })();
    return Offline;
  });

}).call(this);
